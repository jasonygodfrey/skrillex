"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./utils/app.js":
/*!**********************!*\
  !*** ./utils/app.js ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeThreeJS: function() { return /* binding */ initializeThreeJS; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer.js */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_RenderPass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var simplex_noise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! simplex-noise */ \"./node_modules/simplex-noise/dist/esm/simplex-noise.js\");\n\n\n\n\n\nfunction initializeThreeJS(mountPoint) {\n    // Initialize the noise generator\n    const noise3DFunction = (0,simplex_noise__WEBPACK_IMPORTED_MODULE_0__.createNoise3D)();\n    const mouseRadius = 0.1; // Adjust this value as needed\n    const mouseStrength = 0.05; // Adjust this value as needed, if not defined elsewhere\n    // Set up the scene, camera, and renderer\n    const scene = new three__WEBPACK_IMPORTED_MODULE_1__.Scene();\n    const camera = new three__WEBPACK_IMPORTED_MODULE_1__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    const renderer = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer({\n        alpha: true\n    });\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setClearColor(0x000000, 0);\n    mountPoint.appendChild(renderer.domElement);\n    // Initialize the Effect Composer\n    const composer = new three_examples_jsm_postprocessing_EffectComposer_js__WEBPACK_IMPORTED_MODULE_2__.EffectComposer(renderer);\n    const renderPass = new three_examples_jsm_postprocessing_RenderPass_js__WEBPACK_IMPORTED_MODULE_3__.RenderPass(scene, camera);\n    composer.addPass(renderPass);\n    const bloomOptions = {\n        strength: 2.5,\n        radius: 0.6,\n        threshold: 0\n    };\n    const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_4__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(window.innerWidth, window.innerHeight), bloomOptions.strength, bloomOptions.radius, bloomOptions.threshold);\n    composer.addPass(bloomPass);\n    // Define the textureLoader here\n    const textureLoader = new three__WEBPACK_IMPORTED_MODULE_1__.TextureLoader();\n    let mouse = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(10000, 10000);\n    let raycaster = new three__WEBPACK_IMPORTED_MODULE_1__.Raycaster();\n    const cameraParallaxFactor = 0.5;\n    window.addEventListener(\"mousemove\", (e)=>{\n        mouse.x = e.clientX / window.innerWidth * 2 - 1;\n        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\n        mouse.z = 0.5;\n        raycaster.setFromCamera(mouse, camera);\n        if (!raycaster.ray) {\n            console.error(\"Raycaster ray is not initialized.\");\n            return; // Exit the function early to prevent further errors\n        }\n        let intersectPoint = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\n        raycaster.ray.at(1.3, intersectPoint);\n        camera.position.x += (intersectPoint.x * cameraParallaxFactor - camera.position.x) * 0.05;\n        camera.position.y += (-intersectPoint.y * cameraParallaxFactor - camera.position.y) * 0.05;\n        camera.lookAt(scene.position);\n    });\n    window.addEventListener(\"touchstart\", handleTouch);\n    window.addEventListener(\"touchmove\", handleTouch);\n    function handleTouch(e) {\n        e.preventDefault();\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouse.x = touch.clientX / window.innerWidth * 2 - 1;\n            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;\n            mouse.z = 0.5;\n            raycaster.setFromCamera(mouse, camera);\n            const intersectPoint = raycaster.ray.at(1.3);\n            camera.position.x += (intersectPoint.x * cameraParallaxFactor - camera.position.x) * 0.05;\n            camera.position.y += (-intersectPoint.y * cameraParallaxFactor - camera.position.y) * 0.05;\n            camera.lookAt(scene.position);\n        }\n    }\n    const scale = 1; // Adjust this value for your desired scale. E.g., 0.5 means the image will be 50% smaller\n    textureLoader.load(\"skrillex2023logo.png\", (imageTexture)=>{\n        const imgWidth = imageTexture.image.width * scale;\n        const imgHeight = imageTexture.image.height * scale;\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = imgWidth;\n        canvas.height = imgHeight;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(imageTexture.image, 0, 0, imgWidth, imgHeight);\n        const imgData = context.getImageData(0, 0, imgWidth, imgHeight).data;\n        const resolutionFactor = 4;\n        const particleTexture = textureLoader.load(\"particles2.png\");\n        const particlesGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry();\n        const particleVertices = [];\n        const particleColors = [];\n        const originalPositions = [];\n        const increasedBrightness = 2.25; // Place this before the loop\n        for(let y = 0; y < imgHeight; y += resolutionFactor){\n            for(let x = 0; x < imgWidth; x += resolutionFactor){\n                const index = (y * imgWidth + x) * 4;\n                const r = imgData[index];\n                const g = imgData[index + 1];\n                const b = imgData[index + 2];\n                const brightness = 0.7152 * r + 0.2126 * g + 0.0722 * b;\n                if (brightness > 128) {\n                    const xPos = (x / imgWidth - 0.5) * 2;\n                    const yPos = (y / imgHeight - 0.5) * -2;\n                    particleVertices.push(xPos, yPos, 0);\n                    originalPositions.push(xPos, yPos, 0);\n                    particleColors.push(r / 255 * increasedBrightness * 0.8, g / 255 * increasedBrightness, b / 255 * increasedBrightness);\n                }\n            //particleColors.push(1, 0, 0); // Set RGB values to (1, 0, 0) for red\n            }\n        }\n        particlesGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(particleVertices, 3));\n        particlesGeometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(particleColors, 3));\n        const particlesMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.PointsMaterial({\n            size: 0.05,\n            map: particleTexture,\n            vertexColors: true,\n            transparent: true,\n            opacity: 1\n        });\n        const particles = new three__WEBPACK_IMPORTED_MODULE_1__.Points(particlesGeometry, particlesMaterial);\n        scene.add(particles);\n        const radius = 1; // Replace with the desired radius of the circle\n        const segments = 32; // Replace with the desired number of segments to approximate the circle\n        const circleTexture = textureLoader.load(\"circle4.png\");\n        const circleMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            map: circleTexture\n        });\n        const circleGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.CircleGeometry(radius, segments);\n        const circleMesh = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(circleGeometry, circleMaterial);\n        circleMesh.position.set(0, 0, -2);\n        circleMesh.rotation.set(0, 0, 0);\n        //scene.add(circleMesh);\n        // Then, in your animate function:\n        function animate() {\n            const positions = particlesGeometry.attributes.position.array;\n            const time = Date.now() * 0.0001; // adjust the multiplier to control the speed of the animation\n            for(let i = 0; i < positions.length; i += 3){\n                let particlePos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(positions[i], positions[i + 1], positions[i + 2]);\n                let originalPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(originalPositions[i], originalPositions[i + 1], originalPositions[i + 2]);\n                // Calculate the distance between the particle and the mouse\n                let distanceToMouse = particlePos.distanceTo(mouse);\n                // If the distance is less than the mouseRadius, move the particle towards the mouse\n                if (distanceToMouse < mouseRadius) {\n                    particlePos.lerp(mouse, mouseStrength);\n                } else {\n                    // Otherwise, move the particle back to its original position\n                    particlePos.lerp(originalPos, 0.05);\n                }\n                // Use the noise function to get a smooth, varying value for each particle\n                const noiseValue = noise3DFunction(particlePos.x, particlePos.y, time);\n                // Use the noise value to adjust the position of the particle\n                particlePos.z += noiseValue * 0.01; // adjust the multiplier to control the amplitude of the animation\n                positions[i] = particlePos.x;\n                positions[i + 1] = particlePos.y;\n                positions[i + 2] = particlePos.z;\n            }\n            particlesGeometry.attributes.position.needsUpdate = true;\n            //renderer.render(scene, camera);\n            composer.render();\n            requestAnimationFrame(animate);\n        }\n        animate();\n    });\n    camera.position.z = 1.38;\n    window.addEventListener(\"resize\", ()=>{\n        const newWidth = window.innerWidth;\n        const newHeight = window.innerHeight;\n        camera.aspect = newWidth / newHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(newWidth, newHeight);\n        composer.setSize(newWidth, newHeight);\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Iiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2FwcC5qcz9jMjQ0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiO1xyXG5pbXBvcnQgeyBFZmZlY3RDb21wb3NlciB9IGZyb20gXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvRWZmZWN0Q29tcG9zZXIuanNcIjtcclxuaW1wb3J0IHsgUmVuZGVyUGFzcyB9IGZyb20gXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvUmVuZGVyUGFzcy5qc1wiO1xyXG5pbXBvcnQgeyBVbnJlYWxCbG9vbVBhc3MgfSBmcm9tIFwidGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1VucmVhbEJsb29tUGFzcy5qc1wiO1xyXG5pbXBvcnQgeyBjcmVhdGVOb2lzZTNEIH0gZnJvbSAnc2ltcGxleC1ub2lzZSc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZVRocmVlSlMobW91bnRQb2ludCkge1xyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgbm9pc2UgZ2VuZXJhdG9yXHJcbiAgICBjb25zdCBub2lzZTNERnVuY3Rpb24gPSBjcmVhdGVOb2lzZTNEKCk7XHJcblxyXG4gICAgY29uc3QgbW91c2VSYWRpdXMgPSAwLjE7IC8vIEFkanVzdCB0aGlzIHZhbHVlIGFzIG5lZWRlZFxyXG5jb25zdCBtb3VzZVN0cmVuZ3RoID0gMC4wNTsgLy8gQWRqdXN0IHRoaXMgdmFsdWUgYXMgbmVlZGVkLCBpZiBub3QgZGVmaW5lZCBlbHNld2hlcmVcclxuXHJcblxyXG4gICAgLy8gU2V0IHVwIHRoZSBzY2VuZSwgY2FtZXJhLCBhbmQgcmVuZGVyZXJcclxuICAgIGNvbnN0IHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XHJcbiAgICBjb25zdCBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDEwMDApO1xyXG4gICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcih7IGFscGhhOiB0cnVlIH0pO1xyXG4gICAgcmVuZGVyZXIuc2V0U2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcclxuICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IoMHgwMDAwMDAsIDApO1xyXG5cclxuICAgIG1vdW50UG9pbnQuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgRWZmZWN0IENvbXBvc2VyXHJcbiAgICBjb25zdCBjb21wb3NlciA9IG5ldyBFZmZlY3RDb21wb3NlcihyZW5kZXJlcik7XHJcblxyXG4gICAgY29uc3QgcmVuZGVyUGFzcyA9IG5ldyBSZW5kZXJQYXNzKHNjZW5lLCBjYW1lcmEpO1xyXG4gICAgY29tcG9zZXIuYWRkUGFzcyhyZW5kZXJQYXNzKTtcclxuXHJcbiAgICBjb25zdCBibG9vbU9wdGlvbnMgPSB7XHJcbiAgICAgICAgc3RyZW5ndGg6IDIuNSxcclxuICAgICAgICByYWRpdXM6IDAuNixcclxuICAgICAgICB0aHJlc2hvbGQ6IDBcclxuICAgIH07XHJcbiAgICBjb25zdCBibG9vbVBhc3MgPSBuZXcgVW5yZWFsQmxvb21QYXNzKG5ldyBUSFJFRS5WZWN0b3IyKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpLCBibG9vbU9wdGlvbnMuc3RyZW5ndGgsIGJsb29tT3B0aW9ucy5yYWRpdXMsIGJsb29tT3B0aW9ucy50aHJlc2hvbGQpO1xyXG4gICAgY29tcG9zZXIuYWRkUGFzcyhibG9vbVBhc3MpO1xyXG5cclxuICAgIC8vIERlZmluZSB0aGUgdGV4dHVyZUxvYWRlciBoZXJlXHJcbmNvbnN0IHRleHR1cmVMb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xyXG5cclxuICAgIGxldCBtb3VzZSA9IG5ldyBUSFJFRS5WZWN0b3IyKDEwMDAwLCAxMDAwMCk7XHJcbiAgICBsZXQgcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpO1xyXG5cclxuICAgIGNvbnN0IGNhbWVyYVBhcmFsbGF4RmFjdG9yID0gMC41O1xyXG5cclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZSkgPT4ge1xyXG4gICAgICAgIG1vdXNlLnggPSAoZS5jbGllbnRYIC8gd2luZG93LmlubmVyV2lkdGgpICogMiAtIDE7XHJcbiAgICAgICAgbW91c2UueSA9IC0oZS5jbGllbnRZIC8gd2luZG93LmlubmVySGVpZ2h0KSAqIDIgKyAxO1xyXG4gICAgICAgIG1vdXNlLnogPSAwLjU7XHJcbiAgICBcclxuICAgICAgICByYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShtb3VzZSwgY2FtZXJhKTtcclxuICAgIFxyXG4gICAgICAgIGlmICghcmF5Y2FzdGVyLnJheSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdSYXljYXN0ZXIgcmF5IGlzIG5vdCBpbml0aWFsaXplZC4nKTtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBFeGl0IHRoZSBmdW5jdGlvbiBlYXJseSB0byBwcmV2ZW50IGZ1cnRoZXIgZXJyb3JzXHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgbGV0IGludGVyc2VjdFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICByYXljYXN0ZXIucmF5LmF0KDEuMywgaW50ZXJzZWN0UG9pbnQpO1xyXG4gICAgXHJcbiAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnggKz0gKGludGVyc2VjdFBvaW50LnggKiBjYW1lcmFQYXJhbGxheEZhY3RvciAtIGNhbWVyYS5wb3NpdGlvbi54KSAqIDAuMDU7XHJcbiAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnkgKz0gKC1pbnRlcnNlY3RQb2ludC55ICogY2FtZXJhUGFyYWxsYXhGYWN0b3IgLSBjYW1lcmEucG9zaXRpb24ueSkgKiAwLjA1O1xyXG4gICAgICAgIGNhbWVyYS5sb29rQXQoc2NlbmUucG9zaXRpb24pO1xyXG4gICAgfSk7XHJcbiAgICBcclxuXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVRvdWNoKTtcclxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBoYW5kbGVUb3VjaCk7XHJcbiAgICBcclxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoKGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdO1xyXG5cclxuICAgICAgICAgICAgbW91c2UueCA9ICh0b3VjaC5jbGllbnRYIC8gd2luZG93LmlubmVyV2lkdGgpICogMiAtIDE7XHJcbiAgICAgICAgICAgIG1vdXNlLnkgPSAtKHRvdWNoLmNsaWVudFkgLyB3aW5kb3cuaW5uZXJIZWlnaHQpICogMiArIDE7XHJcbiAgICAgICAgICAgIG1vdXNlLnogPSAwLjU7XHJcblxyXG4gICAgICAgICAgICByYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShtb3VzZSwgY2FtZXJhKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdFBvaW50ID0gcmF5Y2FzdGVyLnJheS5hdCgxLjMpO1xyXG5cclxuICAgICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnggKz0gKGludGVyc2VjdFBvaW50LnggKiBjYW1lcmFQYXJhbGxheEZhY3RvciAtIGNhbWVyYS5wb3NpdGlvbi54KSAqIDAuMDU7XHJcbiAgICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi55ICs9ICgtaW50ZXJzZWN0UG9pbnQueSAqIGNhbWVyYVBhcmFsbGF4RmFjdG9yIC0gY2FtZXJhLnBvc2l0aW9uLnkpICogMC4wNTtcclxuICAgICAgICAgICAgY2FtZXJhLmxvb2tBdChzY2VuZS5wb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5jb25zdCBzY2FsZSA9IDE7IC8vIEFkanVzdCB0aGlzIHZhbHVlIGZvciB5b3VyIGRlc2lyZWQgc2NhbGUuIEUuZy4sIDAuNSBtZWFucyB0aGUgaW1hZ2Ugd2lsbCBiZSA1MCUgc21hbGxlclxyXG5cclxudGV4dHVyZUxvYWRlci5sb2FkKCdza3JpbGxleDIwMjNsb2dvLnBuZycsIChpbWFnZVRleHR1cmUpID0+IHtcclxuICAgIGNvbnN0IGltZ1dpZHRoID0gaW1hZ2VUZXh0dXJlLmltYWdlLndpZHRoICogc2NhbGU7XHJcbiAgICBjb25zdCBpbWdIZWlnaHQgPSBpbWFnZVRleHR1cmUuaW1hZ2UuaGVpZ2h0ICogc2NhbGU7XHJcbiAgICBcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gaW1nV2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1nSGVpZ2h0O1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgXHJcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZVRleHR1cmUuaW1hZ2UsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xyXG5cclxuICAgIGNvbnN0IGltZ0RhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KS5kYXRhO1xyXG4gICAgY29uc3QgcmVzb2x1dGlvbkZhY3RvciA9IDQ7XHJcblxyXG4gICAgY29uc3QgcGFydGljbGVUZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCdwYXJ0aWNsZXMyLnBuZycpO1xyXG4gICAgY29uc3QgcGFydGljbGVzR2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcclxuICAgIGNvbnN0IHBhcnRpY2xlVmVydGljZXMgPSBbXTtcclxuICAgIGNvbnN0IHBhcnRpY2xlQ29sb3JzID0gW107XHJcbiAgICBjb25zdCBvcmlnaW5hbFBvc2l0aW9ucyA9IFtdO1xyXG4gICAgY29uc3QgaW5jcmVhc2VkQnJpZ2h0bmVzcyA9IDIuMjU7IC8vIFBsYWNlIHRoaXMgYmVmb3JlIHRoZSBsb29wXHJcblxyXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBpbWdIZWlnaHQ7IHkgKz0gcmVzb2x1dGlvbkZhY3Rvcikge1xyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgaW1nV2lkdGg7IHggKz0gcmVzb2x1dGlvbkZhY3Rvcikge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9ICh5ICogaW1nV2lkdGggKyB4KSAqIDQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBpbWdEYXRhW2luZGV4XTtcclxuICAgICAgICAgICAgY29uc3QgZyA9IGltZ0RhdGFbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgY29uc3QgYiA9IGltZ0RhdGFbaW5kZXggKyAyXTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGJyaWdodG5lc3MgPSAwLjcxNTIgKiByICsgMC4yMTI2ICogZyArIDAuMDcyMiAqIGI7XHJcbiAgICAgICAgICAgIGlmIChicmlnaHRuZXNzID4gMTI4KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4UG9zID0gKHggLyBpbWdXaWR0aCAtIDAuNSkgKiAyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeVBvcyA9ICh5IC8gaW1nSGVpZ2h0IC0gMC41KSAqIC0yO1xyXG4gICAgICAgICAgICAgICAgcGFydGljbGVWZXJ0aWNlcy5wdXNoKHhQb3MsIHlQb3MsIDApO1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQb3NpdGlvbnMucHVzaCh4UG9zLCB5UG9zLCAwKTtcclxucGFydGljbGVDb2xvcnMucHVzaCgociAvIDI1NSkgKiBpbmNyZWFzZWRCcmlnaHRuZXNzICogMC44LCAoZyAvIDI1NSkgKiBpbmNyZWFzZWRCcmlnaHRuZXNzLCAoYiAvIDI1NSkgKiBpbmNyZWFzZWRCcmlnaHRuZXNzKTsgICAgICAgICAgICB9XHJcbi8vcGFydGljbGVDb2xvcnMucHVzaCgxLCAwLCAwKTsgLy8gU2V0IFJHQiB2YWx1ZXMgdG8gKDEsIDAsIDApIGZvciByZWRcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHBhcnRpY2xlc0dlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwYXJ0aWNsZVZlcnRpY2VzLCAzKSk7XHJcbiAgICBwYXJ0aWNsZXNHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocGFydGljbGVDb2xvcnMsIDMpKTtcclxuXHJcbiAgICBjb25zdCBwYXJ0aWNsZXNNYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7IFxyXG4gICAgICAgIHNpemU6IDAuMDUsIFxyXG4gICAgICAgIG1hcDogcGFydGljbGVUZXh0dXJlLCBcclxuICAgICAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsIFxyXG4gICAgICAgIHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gICAgICAgIG9wYWNpdHk6IDEsIC8vIEFkanVzdCB0aGlzIHZhbHVlXHJcbiAgICAgICAgXHJcblxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBwYXJ0aWNsZXMgPSBuZXcgVEhSRUUuUG9pbnRzKHBhcnRpY2xlc0dlb21ldHJ5LCBwYXJ0aWNsZXNNYXRlcmlhbCk7XHJcbiAgICBzY2VuZS5hZGQocGFydGljbGVzKTtcclxuXHJcblxyXG4gICAgY29uc3QgcmFkaXVzID0gMTsgLy8gUmVwbGFjZSB3aXRoIHRoZSBkZXNpcmVkIHJhZGl1cyBvZiB0aGUgY2lyY2xlXHJcbmNvbnN0IHNlZ21lbnRzID0gMzI7IC8vIFJlcGxhY2Ugd2l0aCB0aGUgZGVzaXJlZCBudW1iZXIgb2Ygc2VnbWVudHMgdG8gYXBwcm94aW1hdGUgdGhlIGNpcmNsZVxyXG4gICAgXHJcbiAgICBjb25zdCBjaXJjbGVUZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCdjaXJjbGU0LnBuZycpO1xyXG4gICAgY29uc3QgY2lyY2xlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoeyBtYXA6IGNpcmNsZVRleHR1cmUgfSk7XHJcbiAgICBjb25zdCBjaXJjbGVHZW9tZXRyeSA9IG5ldyBUSFJFRS5DaXJjbGVHZW9tZXRyeShyYWRpdXMsIHNlZ21lbnRzKTtcclxuICAgIGNvbnN0IGNpcmNsZU1lc2ggPSBuZXcgVEhSRUUuTWVzaChjaXJjbGVHZW9tZXRyeSwgY2lyY2xlTWF0ZXJpYWwpO1xyXG4gICAgY2lyY2xlTWVzaC5wb3NpdGlvbi5zZXQoMCwgMCwgLTIpO1xyXG4gICAgICAgIGNpcmNsZU1lc2gucm90YXRpb24uc2V0KDAsIDAsIDApO1xyXG4vL3NjZW5lLmFkZChjaXJjbGVNZXNoKTtcclxuXHJcbi8vIFRoZW4sIGluIHlvdXIgYW5pbWF0ZSBmdW5jdGlvbjpcclxuZnVuY3Rpb24gYW5pbWF0ZSgpIHtcclxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IHBhcnRpY2xlc0dlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcbiAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKSAqIDAuMDAwMTsgIC8vIGFkanVzdCB0aGUgbXVsdGlwbGllciB0byBjb250cm9sIHRoZSBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uXHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgICBsZXQgcGFydGljbGVQb3MgPSBuZXcgVEhSRUUuVmVjdG9yMyhwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV0sIHBvc2l0aW9uc1tpICsgMl0pO1xyXG4gICAgICAgIGxldCBvcmlnaW5hbFBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKG9yaWdpbmFsUG9zaXRpb25zW2ldLCBvcmlnaW5hbFBvc2l0aW9uc1tpICsgMV0sIG9yaWdpbmFsUG9zaXRpb25zW2kgKyAyXSk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcGFydGljbGUgYW5kIHRoZSBtb3VzZVxyXG4gICAgICAgIGxldCBkaXN0YW5jZVRvTW91c2UgPSBwYXJ0aWNsZVBvcy5kaXN0YW5jZVRvKG1vdXNlKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGRpc3RhbmNlIGlzIGxlc3MgdGhhbiB0aGUgbW91c2VSYWRpdXMsIG1vdmUgdGhlIHBhcnRpY2xlIHRvd2FyZHMgdGhlIG1vdXNlXHJcbiAgICAgICAgaWYgKGRpc3RhbmNlVG9Nb3VzZSA8IG1vdXNlUmFkaXVzKSB7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlUG9zLmxlcnAobW91c2UsIG1vdXNlU3RyZW5ndGgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgbW92ZSB0aGUgcGFydGljbGUgYmFjayB0byBpdHMgb3JpZ2luYWwgcG9zaXRpb25cclxuICAgICAgICAgICAgcGFydGljbGVQb3MubGVycChvcmlnaW5hbFBvcywgMC4wNSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgdGhlIG5vaXNlIGZ1bmN0aW9uIHRvIGdldCBhIHNtb290aCwgdmFyeWluZyB2YWx1ZSBmb3IgZWFjaCBwYXJ0aWNsZVxyXG4gICAgICAgIGNvbnN0IG5vaXNlVmFsdWUgPSBub2lzZTNERnVuY3Rpb24ocGFydGljbGVQb3MueCwgcGFydGljbGVQb3MueSwgdGltZSk7XHJcblxyXG4gICAgICAgIC8vIFVzZSB0aGUgbm9pc2UgdmFsdWUgdG8gYWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgcGFydGljbGVcclxuICAgICAgICBwYXJ0aWNsZVBvcy56ICs9IG5vaXNlVmFsdWUgKiAwLjAxOyAgLy8gYWRqdXN0IHRoZSBtdWx0aXBsaWVyIHRvIGNvbnRyb2wgdGhlIGFtcGxpdHVkZSBvZiB0aGUgYW5pbWF0aW9uXHJcblxyXG4gICAgICAgIHBvc2l0aW9uc1tpXSA9IHBhcnRpY2xlUG9zLng7XHJcbiAgICAgICAgcG9zaXRpb25zW2kgKyAxXSA9IHBhcnRpY2xlUG9zLnk7XHJcbiAgICAgICAgcG9zaXRpb25zW2kgKyAyXSA9IHBhcnRpY2xlUG9zLno7XHJcbiAgICB9XHJcblxyXG4gICAgcGFydGljbGVzR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgLy9yZW5kZXJlci5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7XHJcbiAgICBjb21wb3Nlci5yZW5kZXIoKTtcclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxufVxyXG5cclxuICAgIGFuaW1hdGUoKTtcclxufSk7XHJcblxyXG5jYW1lcmEucG9zaXRpb24ueiA9IDEuMzg7XHJcblxyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgKCkgPT4ge1xyXG4gICAgY29uc3QgbmV3V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgIGNvbnN0IG5ld0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuXHJcbiAgICBjYW1lcmEuYXNwZWN0ID0gbmV3V2lkdGggLyBuZXdIZWlnaHQ7XHJcbiAgICBjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuICAgIHJlbmRlcmVyLnNldFNpemUobmV3V2lkdGgsIG5ld0hlaWdodCk7XHJcbiAgICBjb21wb3Nlci5zZXRTaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xyXG59KTtcclxufSJdLCJuYW1lcyI6WyJUSFJFRSIsIkVmZmVjdENvbXBvc2VyIiwiUmVuZGVyUGFzcyIsIlVucmVhbEJsb29tUGFzcyIsImNyZWF0ZU5vaXNlM0QiLCJpbml0aWFsaXplVGhyZWVKUyIsIm1vdW50UG9pbnQiLCJub2lzZTNERnVuY3Rpb24iLCJtb3VzZVJhZGl1cyIsIm1vdXNlU3RyZW5ndGgiLCJzY2VuZSIsIlNjZW5lIiwiY2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJyZW5kZXJlciIsIldlYkdMUmVuZGVyZXIiLCJhbHBoYSIsInNldFNpemUiLCJzZXRDbGVhckNvbG9yIiwiYXBwZW5kQ2hpbGQiLCJkb21FbGVtZW50IiwiY29tcG9zZXIiLCJyZW5kZXJQYXNzIiwiYWRkUGFzcyIsImJsb29tT3B0aW9ucyIsInN0cmVuZ3RoIiwicmFkaXVzIiwidGhyZXNob2xkIiwiYmxvb21QYXNzIiwiVmVjdG9yMiIsInRleHR1cmVMb2FkZXIiLCJUZXh0dXJlTG9hZGVyIiwibW91c2UiLCJyYXljYXN0ZXIiLCJSYXljYXN0ZXIiLCJjYW1lcmFQYXJhbGxheEZhY3RvciIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwieCIsImNsaWVudFgiLCJ5IiwiY2xpZW50WSIsInoiLCJzZXRGcm9tQ2FtZXJhIiwicmF5IiwiY29uc29sZSIsImVycm9yIiwiaW50ZXJzZWN0UG9pbnQiLCJWZWN0b3IzIiwiYXQiLCJwb3NpdGlvbiIsImxvb2tBdCIsImhhbmRsZVRvdWNoIiwicHJldmVudERlZmF1bHQiLCJ0b3VjaGVzIiwibGVuZ3RoIiwidG91Y2giLCJzY2FsZSIsImxvYWQiLCJpbWFnZVRleHR1cmUiLCJpbWdXaWR0aCIsImltYWdlIiwid2lkdGgiLCJpbWdIZWlnaHQiLCJoZWlnaHQiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsImltZ0RhdGEiLCJnZXRJbWFnZURhdGEiLCJkYXRhIiwicmVzb2x1dGlvbkZhY3RvciIsInBhcnRpY2xlVGV4dHVyZSIsInBhcnRpY2xlc0dlb21ldHJ5IiwiQnVmZmVyR2VvbWV0cnkiLCJwYXJ0aWNsZVZlcnRpY2VzIiwicGFydGljbGVDb2xvcnMiLCJvcmlnaW5hbFBvc2l0aW9ucyIsImluY3JlYXNlZEJyaWdodG5lc3MiLCJpbmRleCIsInIiLCJnIiwiYiIsImJyaWdodG5lc3MiLCJ4UG9zIiwieVBvcyIsInB1c2giLCJzZXRBdHRyaWJ1dGUiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwicGFydGljbGVzTWF0ZXJpYWwiLCJQb2ludHNNYXRlcmlhbCIsInNpemUiLCJtYXAiLCJ2ZXJ0ZXhDb2xvcnMiLCJ0cmFuc3BhcmVudCIsIm9wYWNpdHkiLCJwYXJ0aWNsZXMiLCJQb2ludHMiLCJhZGQiLCJzZWdtZW50cyIsImNpcmNsZVRleHR1cmUiLCJjaXJjbGVNYXRlcmlhbCIsIk1lc2hCYXNpY01hdGVyaWFsIiwiY2lyY2xlR2VvbWV0cnkiLCJDaXJjbGVHZW9tZXRyeSIsImNpcmNsZU1lc2giLCJNZXNoIiwic2V0Iiwicm90YXRpb24iLCJhbmltYXRlIiwicG9zaXRpb25zIiwiYXR0cmlidXRlcyIsImFycmF5IiwidGltZSIsIkRhdGUiLCJub3ciLCJpIiwicGFydGljbGVQb3MiLCJvcmlnaW5hbFBvcyIsImRpc3RhbmNlVG9Nb3VzZSIsImRpc3RhbmNlVG8iLCJsZXJwIiwibm9pc2VWYWx1ZSIsIm5lZWRzVXBkYXRlIiwicmVuZGVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJhc3BlY3QiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/app.js\n"));

/***/ })

});