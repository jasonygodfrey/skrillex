"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/rlt",{

/***/ "./utils/app2.js":
/*!***********************!*\
  !*** ./utils/app2.js ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeThreeJS: function() { return /* binding */ initializeThreeJS; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer.js */ \"./node_modules/three/examples/jsm/postprocessing/EffectComposer.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_RenderPass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ \"./node_modules/three/examples/jsm/postprocessing/RenderPass.js\");\n/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ \"./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js\");\n/* harmony import */ var simplex_noise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! simplex-noise */ \"./node_modules/simplex-noise/dist/esm/simplex-noise.js\");\n\n\n\n\n\nfunction initializeThreeJS(mountPoint) {\n    // Initialize the noise generator\n    const noise3DFunction = (0,simplex_noise__WEBPACK_IMPORTED_MODULE_0__.createNoise3D)();\n    // Set up the scene, camera, and renderer\n    const scene = new three__WEBPACK_IMPORTED_MODULE_1__.Scene();\n    scene.fog = new three__WEBPACK_IMPORTED_MODULE_1__.FogExp2(0x000000, 0.2);\n    const camera = new three__WEBPACK_IMPORTED_MODULE_1__.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    const renderer = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer({\n        alpha: true\n    }); // enable alpha channel\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    renderer.setClearColor(0x000000, 0); // the second parameter is the alpha (0 means fully transparent)\n    document.body.appendChild(renderer.domElement);\n    // Initialize the Effect Composer\n    const composer = new three_examples_jsm_postprocessing_EffectComposer_js__WEBPACK_IMPORTED_MODULE_2__.EffectComposer(renderer);\n    const renderPass = new three_examples_jsm_postprocessing_RenderPass_js__WEBPACK_IMPORTED_MODULE_3__.RenderPass(scene, camera);\n    composer.addPass(renderPass);\n    const bloomOptions = {\n        strength: 2.5,\n        radius: 0.6,\n        threshold: 0 // decreased threshold to make more particles bloom\n    };\n    const bloomPass = new three_examples_jsm_postprocessing_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_4__.UnrealBloomPass(new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(window.innerWidth, window.innerHeight), bloomOptions.strength, bloomOptions.radius, bloomOptions.threshold);\n    composer.addPass(bloomPass);\n    // Load the image texture\n    const textureLoader = new three__WEBPACK_IMPORTED_MODULE_1__.TextureLoader();\n    let mouse = new three__WEBPACK_IMPORTED_MODULE_1__.Vector2(10000, 10000);\n    let mouseRadius = 0.2;\n    let mouseStrength = 0.03;\n    let raycaster = new three__WEBPACK_IMPORTED_MODULE_1__.Raycaster();\n    const cameraParallaxFactor = 0.5;\n    window.addEventListener(\"mousemove\", (e)=>{\n        mouse.x = e.clientX / window.innerWidth * 2 - 1;\n        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;\n        mouse.z = 0.5; // depth factor to project into the scene\n        raycaster.setFromCamera(mouse, camera);\n        mouse = raycaster.ray.at(1.3); // the z-position where the particles are\n        // Apply Parallax effect to camera based on mouse movement\n        camera.position.x += (mouse.x * cameraParallaxFactor - camera.position.x) * 0.05;\n        camera.position.y += (-mouse.y * cameraParallaxFactor - camera.position.y) * 0.05;\n        camera.lookAt(scene.position);\n    });\n    window.addEventListener(\"touchstart\", handleTouch);\n    window.addEventListener(\"touchmove\", handleTouch);\n    function handleTouch(e) {\n        e.preventDefault(); // Prevents the default behavior of touch events (like scrolling)\n        // Check if there's at least one touch\n        if (e.touches.length > 0) {\n            const touch = e.touches[0];\n            mouse.x = touch.clientX / window.innerWidth * 2 - 1;\n            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;\n            mouse.z = 0.5; // depth factor to project into the scene\n            raycaster.setFromCamera(mouse, camera);\n            mouse = raycaster.ray.at(1.3); // the z-position where the particles are\n        }\n        // Apply Parallax effect to camera based on touch movement\n        camera.position.x += (mouse.x * cameraParallaxFactor - camera.position.x) * 0.05;\n        camera.position.y += (-mouse.y * cameraParallaxFactor - camera.position.y) * 0.05;\n        camera.lookAt(scene.position);\n    }\n    const scale = 1; // Adjust this value for your desired scale. E.g., 0.5 means the image will be 50% smaller\n    textureLoader.load(\"skrillex2023logo.png\", (imageTexture)=>{\n        const imgWidth = imageTexture.image.width * scale;\n        const imgHeight = imageTexture.image.height * scale;\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = imgWidth;\n        canvas.height = imgHeight;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(imageTexture.image, 0, 0, imgWidth, imgHeight);\n        const imgData = context.getImageData(0, 0, imgWidth, imgHeight).data;\n        const resolutionFactor = 2;\n        const particleTexture = textureLoader.load(\"particles2.png\");\n        const particlesGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry();\n        const particleVertices = [];\n        const particleColors = [];\n        const originalPositions = [];\n        const increasedBrightness = 0.65; // Place this before the loop\n        for(let y = 0; y < imgHeight; y += resolutionFactor){\n            for(let x = 0; x < imgWidth; x += resolutionFactor){\n                const index = (y * imgWidth + x) * 4;\n                const r = imgData[index];\n                const g = imgData[index + 1];\n                const b = imgData[index + 2];\n                const brightness = 0.7152 * r + 0.2126 * g + 0.0722 * b;\n                if (brightness > 128) {\n                    const xPos = (x / imgWidth - 0.5) * 2;\n                    const yPos = (y / imgHeight - 0.5) * -2;\n                    particleVertices.push(xPos, yPos, 0);\n                    originalPositions.push(xPos, yPos, 0);\n                    particleColors.push(r / 255 * increasedBrightness * 0.8, g / 255 * increasedBrightness, b / 255 * increasedBrightness);\n                }\n                particleColors.push(1, 0, 0); // Set RGB values to (1, 0, 0) for red\n                particleColors.push(0xfc / 255, 0x45 / 255, 0x26 / 255); // Set RGB values to #fc4526\n            }\n        }\n        particlesGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(particleVertices, 3));\n        particlesGeometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(particleColors, 3));\n        const particlesMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.PointsMaterial({\n            size: 0.05,\n            map: particleTexture,\n            vertexColors: true,\n            transparent: true,\n            opacity: 2.8\n        });\n        const particles = new three__WEBPACK_IMPORTED_MODULE_1__.Points(particlesGeometry, particlesMaterial);\n        scene.add(particles);\n        const radius = 5; // Replace with the desired radius of the circle\n        const segments = 32; // Replace with the desired number of segments to approximate the circle\n        const circleTexture = textureLoader.load(\"backgroundalbum.png\");\n        const circleMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            map: circleTexture\n        });\n        const circleGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.CircleGeometry(radius, segments);\n        const circleMesh = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(circleGeometry, circleMaterial);\n        circleMesh.position.set(0, 0, -2);\n        circleMesh.rotation.set(0, 0, 0);\n        //scene.add(circleMesh);\n        textureLoader.load(\"circle20.png\", (imageTexture)=>{\n            const scale = 4;\n            const imgWidth = imageTexture.image.width * scale;\n            const imgHeight = imageTexture.image.height * scale;\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = imgWidth;\n            canvas.height = imgHeight;\n            const context = canvas.getContext(\"2d\");\n            context.drawImage(imageTexture.image, 0, 0, imgWidth, imgHeight);\n            const imgData = context.getImageData(0, 0, imgWidth, imgHeight).data;\n            const resolutionFactor = 1; // Increase this value for a more pixelated effect\n            const particleTexture = textureLoader.load(\"particleswhite.png\");\n            const particlesGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry();\n            const particleVertices = [];\n            const particleColors = [];\n            const originalPositions = [];\n            const increasedBrightness = 0.4; // Place this before the loop\n            for(let y = 0; y < imgHeight; y += resolutionFactor){\n                for(let x = 0; x < imgWidth; x += resolutionFactor){\n                    const index = (y * imgWidth + x) * 4;\n                    const r = imgData[index];\n                    const g = imgData[index + 1];\n                    const b = imgData[index + 2];\n                    const brightness = 0.7152 * r + 0.2126 * g + 0.0722 * b;\n                    if (brightness > 128) {\n                        const xPos = (x / imgWidth - 0.5) * 2 * scale; // multiply by scale\n                        const yPos = (y / imgHeight - 0.5) * -2 * scale; // multiply by scale\n                        const zPos = -1; // Adjust this value to set the particles further back\n                        particleVertices.push(xPos, yPos, zPos);\n                        originalPositions.push(xPos, yPos, zPos);\n                        particleColors.push(1, 1, 1); // Set RGB values to white\n                    }\n                }\n            }\n            particlesGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(particleVertices, 3));\n            particlesGeometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(particleColors, 3));\n            const particlesMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.PointsMaterial({\n                size: 0.02,\n                map: particleTexture,\n                vertexColors: true,\n                transparent: true,\n                opacity: 0.01,\n                color: new three__WEBPACK_IMPORTED_MODULE_1__.Color(1, 1, 1) // White\n            });\n            const particles = new three__WEBPACK_IMPORTED_MODULE_1__.Points(particlesGeometry, particlesMaterial);\n            scene.add(particles);\n        });\n        // 1. Load the fire texture\n        const fireTexture = new three__WEBPACK_IMPORTED_MODULE_1__.TextureLoader().load(\"circle4.png\");\n        // 2. Create the particle system material\n        const fireMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.PointsMaterial({\n            map: fireTexture,\n            blending: three__WEBPACK_IMPORTED_MODULE_1__.AdditiveBlending,\n            size: 0.1,\n            transparent: true,\n            opacity: 0.05,\n            vertexColors: true,\n            depthWrite: false // To ensure particles blend properly without depth interference\n        });\n        // 3. Create the particle system geometry\n        const fireGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry();\n        const fireVertices = [];\n        const fireColors = [];\n        const fireSizes = [];\n        for(let i = 0; i < 5000; i++){\n            const x = (Math.random() - 0.5) * 2;\n            const y = Math.random() - 2;\n            const z = (Math.random() - 0.5) * 2;\n            fireVertices.push(x, y, z);\n            const hue = 10 + Math.random() * 10;\n            const saturation = 80 + Math.random() * 20;\n            const lightness = 40 + Math.random() * 2;\n            const color = new three__WEBPACK_IMPORTED_MODULE_1__.Color(\"hsl(\".concat(hue, \", \").concat(saturation, \"%, \").concat(lightness, \"%)\"));\n            fireColors.push(color.r, color.g, color.b);\n        }\n        fireGeometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(fireVertices, 3));\n        fireGeometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(fireColors, 3));\n        fireGeometry.setAttribute(\"size\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(fireSizes, 1)); // NEW: Set varying sizes\n        const fireParticles = new three__WEBPACK_IMPORTED_MODULE_1__.Points(fireGeometry, fireMaterial);\n        scene.add(fireParticles);\n        // 4. Animate the fire particles in your animate function\n        function animateFire() {\n            const positions = fireGeometry.attributes.position.array;\n            for(let i = 0; i < positions.length; i += 3){\n                positions[i + 1] += 0.005 + Math.random() * 0.01; // Add randomness to upward movement\n                if (positions[i + 1] > 0.5) {\n                    positions[i + 1] = -0.5;\n                }\n                positions[i] += (Math.random() - 0.5) * 0.01; // Add slight randomness to x position for flicker\n            }\n            fireGeometry.attributes.position.needsUpdate = true;\n        }\n        // 1. Load the fire2 texture\n        const fire2Texture = new three__WEBPACK_IMPORTED_MODULE_1__.TextureLoader().load(\"particlesred.png\"); // Change the path to the new texture\n        // 2. Create the particle system material for fire2\n        const fire2Material = new three__WEBPACK_IMPORTED_MODULE_1__.PointsMaterial({\n            map: fire2Texture,\n            blending: three__WEBPACK_IMPORTED_MODULE_1__.AdditiveBlending,\n            size: 0.08,\n            transparent: true,\n            opacity: 0.006,\n            vertexColors: true,\n            depthWrite: false\n        });\n        // 3. Create the particle system geometry for fire2\n        const fire2Geometry = new three__WEBPACK_IMPORTED_MODULE_1__.BufferGeometry();\n        const fire2Vertices = [];\n        const fire2Colors = [];\n        const fire2Sizes = [];\n        for(let i = 0; i < 4000; i++){\n            const x = (Math.random() - 0.5) * 2.5; // Wider spread\n            const y = Math.random() - 1.5;\n            const z = (Math.random() - 0.5) * 2.5; // Wider spread\n            fire2Vertices.push(x, y, z);\n            const hue = 5 + Math.random() * 15; // Different color variation\n            const saturation = 85 + Math.random() * 15;\n            const lightness = 35 + Math.random() * 3;\n            const color = new three__WEBPACK_IMPORTED_MODULE_1__.Color(\"hsl(\".concat(hue, \", \").concat(saturation, \"%, \").concat(lightness, \"%)\"));\n            fire2Colors.push(color.r, color.g, color.b);\n        }\n        fire2Geometry.setAttribute(\"position\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(fire2Vertices, 3));\n        fire2Geometry.setAttribute(\"color\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(fire2Colors, 3));\n        fire2Geometry.setAttribute(\"size\", new three__WEBPACK_IMPORTED_MODULE_1__.Float32BufferAttribute(fire2Sizes, 1));\n        const fire2Particles = new three__WEBPACK_IMPORTED_MODULE_1__.Points(fire2Geometry, fire2Material);\n        scene.add(fire2Particles);\n        // 4. Animate the fire2 particles in your animate function\n        function animateFire2() {\n            const positions = fire2Geometry.attributes.position.array;\n            for(let i = 0; i < positions.length; i += 3){\n                positions[i + 1] += 0.004 + Math.random() * 0.009; // Different movement speed\n                if (positions[i + 1] > 0.6) {\n                    positions[i + 1] = -0.6;\n                }\n                positions[i] += (Math.random() - 0.5) * 0.012; // Different flicker\n            }\n            fire2Geometry.attributes.position.needsUpdate = true;\n        }\n        // Create a red square plane geometry\n        const squareSize = 4.5; // Adjust the size as needed\n        const squareGeometry = new three__WEBPACK_IMPORTED_MODULE_1__.PlaneGeometry(squareSize, squareSize);\n        const squareMaterial = new three__WEBPACK_IMPORTED_MODULE_1__.MeshBasicMaterial({\n            color: 0xff0000\n        }); // Red color\n        const squareMesh = new three__WEBPACK_IMPORTED_MODULE_1__.Mesh(squareGeometry, squareMaterial);\n        squareMesh.rotation.x = -Math.PI / 2; // Rotate the square 90 degrees to lay it flat\n        squareMesh.position.set(0, -2.7, 0); // Adjust the y-value to set the height of the ground\n        scene.add(squareMesh);\n        // Then, in your animate function:\n        function animate() {\n            animateFire();\n            animateFire2();\n            const positions = particlesGeometry.attributes.position.array;\n            const time = Date.now() * 0.0001; // adjust the multiplier to control the speed of the animation\n            for(let i = 0; i < positions.length; i += 3){\n                let particlePos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(positions[i], positions[i + 1], positions[i + 2]);\n                let originalPos = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(originalPositions[i], originalPositions[i + 1], originalPositions[i + 2]);\n                // Calculate the distance between the particle and the mouse\n                let distanceToMouse = particlePos.distanceTo(mouse);\n                // If the distance is less than the mouseRadius, move the particle towards the mouse\n                if (distanceToMouse < mouseRadius) {\n                    particlePos.lerp(mouse, mouseStrength);\n                } else {\n                    // Otherwise, move the particle back to its original position\n                    particlePos.lerp(originalPos, 0.05);\n                }\n                // Use the noise function to get a smooth, varying value for each particle\n                const noiseValue = noise3DFunction(particlePos.x, particlePos.y, time);\n                // Use the noise value to adjust the position of the particle\n                particlePos.z += noiseValue * 0.01; // adjust the multiplier to control the amplitude of the animation\n                positions[i] = particlePos.x;\n                positions[i + 1] = particlePos.y;\n                positions[i + 2] = particlePos.z;\n            }\n            particlesGeometry.attributes.position.needsUpdate = true;\n            //renderer.render(scene, camera);\n            composer.render();\n            requestAnimationFrame(animate);\n        }\n        animate();\n    });\n    camera.position.z = 1.38;\n    window.addEventListener(\"resize\", ()=>{\n        const newWidth = window.innerWidth;\n        const newHeight = window.innerHeight;\n        camera.aspect = newWidth / newHeight;\n        camera.updateProjectionMatrix();\n        renderer.setSize(newWidth, newHeight);\n        composer.setSize(newWidth, newHeight);\n    });\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RHFILFlBQVlLLElBQUksQ0FBQ0gsYUFBYTtnQkFDbEM7Z0JBRUEsMEVBQTBFO2dCQUMxRSxNQUFNSSxhQUFhM0osZ0JBQWdCcUosWUFBWS9HLENBQUMsRUFBRStHLFlBQVk3RyxDQUFDLEVBQUUwRztnQkFFakUsNkRBQTZEO2dCQUM3REcsWUFBWTNHLENBQUMsSUFBSWlILGFBQWEsTUFBTyxrRUFBa0U7Z0JBRXZHNUIsU0FBUyxDQUFDUixFQUFFLEdBQUc4QixZQUFZL0csQ0FBQztnQkFDNUJ5RixTQUFTLENBQUNSLElBQUksRUFBRSxHQUFHOEIsWUFBWTdHLENBQUM7Z0JBQ2hDdUYsU0FBUyxDQUFDUixJQUFJLEVBQUUsR0FBRzhCLFlBQVkzRyxDQUFDO1lBQ3BDO1lBRUE2QixrQkFBa0J5RCxVQUFVLENBQUNsRixRQUFRLENBQUNvRixXQUFXLEdBQUc7WUFFcEQsaUNBQWlDO1lBQ2pDL0csU0FBU3lJLE1BQU07WUFDZkMsc0JBQXNCWjtRQUUxQjtRQUVBQTtJQUNKO0lBRUE1SSxPQUFPeUMsUUFBUSxDQUFDSixDQUFDLEdBQUc7SUFFcEJuQyxPQUFPNkIsZ0JBQWdCLENBQUMsVUFBVTtRQUM5QixNQUFNMEgsV0FBV3ZKLE9BQU9DLFVBQVU7UUFDbEMsTUFBTXVKLFlBQVl4SixPQUFPRSxXQUFXO1FBRXBDSixPQUFPMkosTUFBTSxHQUFHRixXQUFXQztRQUMzQjFKLE9BQU80SixzQkFBc0I7UUFFN0J2SixTQUFTRyxPQUFPLENBQUNpSixVQUFVQztRQUMzQjVJLFNBQVNOLE9BQU8sQ0FBQ2lKLFVBQVVDO0lBQy9CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvYXBwMi5qcz80MWE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gXCJ0aHJlZVwiO1xyXG5pbXBvcnQgeyBFZmZlY3RDb21wb3NlciB9IGZyb20gXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvRWZmZWN0Q29tcG9zZXIuanNcIjtcclxuaW1wb3J0IHsgUmVuZGVyUGFzcyB9IGZyb20gXCJ0aHJlZS9leGFtcGxlcy9qc20vcG9zdHByb2Nlc3NpbmcvUmVuZGVyUGFzcy5qc1wiO1xyXG5pbXBvcnQgeyBVbnJlYWxCbG9vbVBhc3MgfSBmcm9tIFwidGhyZWUvZXhhbXBsZXMvanNtL3Bvc3Rwcm9jZXNzaW5nL1VucmVhbEJsb29tUGFzcy5qc1wiO1xyXG5pbXBvcnQgeyBjcmVhdGVOb2lzZTNEIH0gZnJvbSAnc2ltcGxleC1ub2lzZSc7XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVUaHJlZUpTKG1vdW50UG9pbnQpIHtcclxuLy8gSW5pdGlhbGl6ZSB0aGUgbm9pc2UgZ2VuZXJhdG9yXHJcbmNvbnN0IG5vaXNlM0RGdW5jdGlvbiA9IGNyZWF0ZU5vaXNlM0QoKTtcclxuLy8gU2V0IHVwIHRoZSBzY2VuZSwgY2FtZXJhLCBhbmQgcmVuZGVyZXJcclxuY29uc3Qgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcclxuc2NlbmUuZm9nID0gbmV3IFRIUkVFLkZvZ0V4cDIoMHgwMDAwMDAsIDAuMik7XHJcblxyXG5jb25zdCBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LmlubmVySGVpZ2h0LCAwLjEsIDEwMDApO1xyXG5jb25zdCByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHsgYWxwaGE6IHRydWUgfSk7ICAvLyBlbmFibGUgYWxwaGEgY2hhbm5lbFxyXG5yZW5kZXJlci5zZXRTaXplKHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xyXG5yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4MDAwMDAwLCAwKTsgIC8vIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBhbHBoYSAoMCBtZWFucyBmdWxseSB0cmFuc3BhcmVudClcclxuXHJcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocmVuZGVyZXIuZG9tRWxlbWVudCk7XHJcblxyXG5cclxuLy8gSW5pdGlhbGl6ZSB0aGUgRWZmZWN0IENvbXBvc2VyXHJcbmNvbnN0IGNvbXBvc2VyID0gbmV3IEVmZmVjdENvbXBvc2VyKHJlbmRlcmVyKTtcclxuXHJcbmNvbnN0IHJlbmRlclBhc3MgPSBuZXcgUmVuZGVyUGFzcyhzY2VuZSwgY2FtZXJhKTtcclxuY29tcG9zZXIuYWRkUGFzcyhyZW5kZXJQYXNzKTtcclxuXHJcbmNvbnN0IGJsb29tT3B0aW9ucyA9IHtcclxuICAgIHN0cmVuZ3RoOiAyLjUsICAgLy8gaW5jcmVhc2VkIHN0cmVuZ3RoXHJcbiAgICByYWRpdXM6IDAuNiwgICAgIC8vIGluY3JlYXNlZCByYWRpdXMgZm9yIGEgYnJvYWRlciBnbG93XHJcbiAgICB0aHJlc2hvbGQ6IDAgICAvLyBkZWNyZWFzZWQgdGhyZXNob2xkIHRvIG1ha2UgbW9yZSBwYXJ0aWNsZXMgYmxvb21cclxufTtcclxuY29uc3QgYmxvb21QYXNzID0gbmV3IFVucmVhbEJsb29tUGFzcyhuZXcgVEhSRUUuVmVjdG9yMih3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KSwgYmxvb21PcHRpb25zLnN0cmVuZ3RoLCBibG9vbU9wdGlvbnMucmFkaXVzLCBibG9vbU9wdGlvbnMudGhyZXNob2xkKTtcclxuY29tcG9zZXIuYWRkUGFzcyhibG9vbVBhc3MpO1xyXG4vLyBMb2FkIHRoZSBpbWFnZSB0ZXh0dXJlXHJcbmNvbnN0IHRleHR1cmVMb2FkZXIgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpO1xyXG5cclxubGV0IG1vdXNlID0gbmV3IFRIUkVFLlZlY3RvcjIoMTAwMDAsIDEwMDAwKTtcclxubGV0IG1vdXNlUmFkaXVzID0gMC4yO1xyXG5sZXQgbW91c2VTdHJlbmd0aCA9IDAuMDM7XHJcbmxldCByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKCk7XHJcblxyXG5jb25zdCBjYW1lcmFQYXJhbGxheEZhY3RvciA9IDAuNTtcclxuXHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZSkgPT4ge1xyXG4gICAgbW91c2UueCA9IChlLmNsaWVudFggLyB3aW5kb3cuaW5uZXJXaWR0aCkgKiAyIC0gMTtcclxuICAgIG1vdXNlLnkgPSAtKGUuY2xpZW50WSAvIHdpbmRvdy5pbm5lckhlaWdodCkgKiAyICsgMTtcclxuICAgIG1vdXNlLnogPSAwLjU7ICAvLyBkZXB0aCBmYWN0b3IgdG8gcHJvamVjdCBpbnRvIHRoZSBzY2VuZVxyXG5cclxuICAgIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKG1vdXNlLCBjYW1lcmEpO1xyXG4gICAgbW91c2UgPSByYXljYXN0ZXIucmF5LmF0KDEuMyk7ICAvLyB0aGUgei1wb3NpdGlvbiB3aGVyZSB0aGUgcGFydGljbGVzIGFyZVxyXG5cclxuICAgIC8vIEFwcGx5IFBhcmFsbGF4IGVmZmVjdCB0byBjYW1lcmEgYmFzZWQgb24gbW91c2UgbW92ZW1lbnRcclxuICAgIGNhbWVyYS5wb3NpdGlvbi54ICs9IChtb3VzZS54ICogY2FtZXJhUGFyYWxsYXhGYWN0b3IgLSBjYW1lcmEucG9zaXRpb24ueCkgKiAwLjA1O1xyXG4gICAgY2FtZXJhLnBvc2l0aW9uLnkgKz0gKC1tb3VzZS55ICogY2FtZXJhUGFyYWxsYXhGYWN0b3IgLSBjYW1lcmEucG9zaXRpb24ueSkgKiAwLjA1O1xyXG4gICAgY2FtZXJhLmxvb2tBdChzY2VuZS5wb3NpdGlvbik7XHJcbn0pO1xyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVRvdWNoKTtcclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGhhbmRsZVRvdWNoKTtcclxuZnVuY3Rpb24gaGFuZGxlVG91Y2goZSkge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAgLy8gUHJldmVudHMgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgdG91Y2ggZXZlbnRzIChsaWtlIHNjcm9sbGluZylcclxuXHJcbiAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGF0IGxlYXN0IG9uZSB0b3VjaFxyXG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgY29uc3QgdG91Y2ggPSBlLnRvdWNoZXNbMF07XHJcblxyXG4gICAgICAgIG1vdXNlLnggPSAodG91Y2guY2xpZW50WCAvIHdpbmRvdy5pbm5lcldpZHRoKSAqIDIgLSAxO1xyXG4gICAgICAgIG1vdXNlLnkgPSAtKHRvdWNoLmNsaWVudFkgLyB3aW5kb3cuaW5uZXJIZWlnaHQpICogMiArIDE7XHJcbiAgICAgICAgbW91c2UueiA9IDAuNTsgIC8vIGRlcHRoIGZhY3RvciB0byBwcm9qZWN0IGludG8gdGhlIHNjZW5lXHJcblxyXG4gICAgICAgIHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKG1vdXNlLCBjYW1lcmEpO1xyXG4gICAgICAgIG1vdXNlID0gcmF5Y2FzdGVyLnJheS5hdCgxLjMpOyAgLy8gdGhlIHotcG9zaXRpb24gd2hlcmUgdGhlIHBhcnRpY2xlcyBhcmVcclxuICAgIH1cclxuICAgIC8vIEFwcGx5IFBhcmFsbGF4IGVmZmVjdCB0byBjYW1lcmEgYmFzZWQgb24gdG91Y2ggbW92ZW1lbnRcclxuICAgIGNhbWVyYS5wb3NpdGlvbi54ICs9IChtb3VzZS54ICogY2FtZXJhUGFyYWxsYXhGYWN0b3IgLSBjYW1lcmEucG9zaXRpb24ueCkgKiAwLjA1O1xyXG4gICAgY2FtZXJhLnBvc2l0aW9uLnkgKz0gKC1tb3VzZS55ICogY2FtZXJhUGFyYWxsYXhGYWN0b3IgLSBjYW1lcmEucG9zaXRpb24ueSkgKiAwLjA1O1xyXG4gICAgY2FtZXJhLmxvb2tBdChzY2VuZS5wb3NpdGlvbik7XHJcbn1cclxuY29uc3Qgc2NhbGUgPSAxOyAvLyBBZGp1c3QgdGhpcyB2YWx1ZSBmb3IgeW91ciBkZXNpcmVkIHNjYWxlLiBFLmcuLCAwLjUgbWVhbnMgdGhlIGltYWdlIHdpbGwgYmUgNTAlIHNtYWxsZXJcclxuXHJcbnRleHR1cmVMb2FkZXIubG9hZCgnc2tyaWxsZXgyMDIzbG9nby5wbmcnLCAoaW1hZ2VUZXh0dXJlKSA9PiB7XHJcbiAgICBjb25zdCBpbWdXaWR0aCA9IGltYWdlVGV4dHVyZS5pbWFnZS53aWR0aCAqIHNjYWxlO1xyXG4gICAgY29uc3QgaW1nSGVpZ2h0ID0gaW1hZ2VUZXh0dXJlLmltYWdlLmhlaWdodCAqIHNjYWxlO1xyXG5cclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gaW1nV2lkdGg7XHJcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1nSGVpZ2h0O1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlVGV4dHVyZS5pbWFnZSwgMCwgMCwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XHJcblxyXG4gICAgY29uc3QgaW1nRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpLmRhdGE7XHJcbiAgICBjb25zdCByZXNvbHV0aW9uRmFjdG9yID0gMjtcclxuXHJcbiAgICBjb25zdCBwYXJ0aWNsZVRleHR1cmUgPSB0ZXh0dXJlTG9hZGVyLmxvYWQoJ3BhcnRpY2xlczIucG5nJyk7XHJcbiAgICBjb25zdCBwYXJ0aWNsZXNHZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xyXG4gICAgY29uc3QgcGFydGljbGVWZXJ0aWNlcyA9IFtdO1xyXG4gICAgY29uc3QgcGFydGljbGVDb2xvcnMgPSBbXTtcclxuICAgIGNvbnN0IG9yaWdpbmFsUG9zaXRpb25zID0gW107XHJcbiAgICBjb25zdCBpbmNyZWFzZWRCcmlnaHRuZXNzID0gMC42NTsgLy8gUGxhY2UgdGhpcyBiZWZvcmUgdGhlIGxvb3BcclxuXHJcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGltZ0hlaWdodDsgeSArPSByZXNvbHV0aW9uRmFjdG9yKSB7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBpbWdXaWR0aDsgeCArPSByZXNvbHV0aW9uRmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gKHkgKiBpbWdXaWR0aCArIHgpICogNDtcclxuICAgICAgICAgICAgY29uc3QgciA9IGltZ0RhdGFbaW5kZXhdO1xyXG4gICAgICAgICAgICBjb25zdCBnID0gaW1nRGF0YVtpbmRleCArIDFdO1xyXG4gICAgICAgICAgICBjb25zdCBiID0gaW1nRGF0YVtpbmRleCArIDJdO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYnJpZ2h0bmVzcyA9IDAuNzE1MiAqIHIgKyAwLjIxMjYgKiBnICsgMC4wNzIyICogYjtcclxuICAgICAgICAgICAgaWYgKGJyaWdodG5lc3MgPiAxMjgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHhQb3MgPSAoeCAvIGltZ1dpZHRoIC0gMC41KSAqIDI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB5UG9zID0gKHkgLyBpbWdIZWlnaHQgLSAwLjUpICogLTI7XHJcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZVZlcnRpY2VzLnB1c2goeFBvcywgeVBvcywgMCk7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFBvc2l0aW9ucy5wdXNoKHhQb3MsIHlQb3MsIDApO1xyXG4gICAgICAgICAgICAgICAgcGFydGljbGVDb2xvcnMucHVzaCgociAvIDI1NSkgKiBpbmNyZWFzZWRCcmlnaHRuZXNzICogMC44LCAoZyAvIDI1NSkgKiBpbmNyZWFzZWRCcmlnaHRuZXNzLCAoYiAvIDI1NSkgKiBpbmNyZWFzZWRCcmlnaHRuZXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJ0aWNsZUNvbG9ycy5wdXNoKDEsIDAsIDApOyAvLyBTZXQgUkdCIHZhbHVlcyB0byAoMSwgMCwgMCkgZm9yIHJlZFxyXG4gICAgICAgICAgICBwYXJ0aWNsZUNvbG9ycy5wdXNoKDB4ZmMgLyAyNTUsIDB4NDUgLyAyNTUsIDB4MjYgLyAyNTUpOyAvLyBTZXQgUkdCIHZhbHVlcyB0byAjZmM0NTI2XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHBhcnRpY2xlc0dlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwYXJ0aWNsZVZlcnRpY2VzLCAzKSk7XHJcbiAgICBwYXJ0aWNsZXNHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUocGFydGljbGVDb2xvcnMsIDMpKTtcclxuXHJcbiAgICBjb25zdCBwYXJ0aWNsZXNNYXRlcmlhbCA9IG5ldyBUSFJFRS5Qb2ludHNNYXRlcmlhbCh7XHJcbiAgICAgICAgc2l6ZTogMC4wNSxcclxuICAgICAgICBtYXA6IHBhcnRpY2xlVGV4dHVyZSxcclxuICAgICAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsXHJcbiAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAgICAgICAgb3BhY2l0eTogMi44LCAvLyBBZGp1c3QgdGhpcyB2YWx1ZVxyXG5cclxuXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHBhcnRpY2xlcyA9IG5ldyBUSFJFRS5Qb2ludHMocGFydGljbGVzR2VvbWV0cnksIHBhcnRpY2xlc01hdGVyaWFsKTtcclxuXHJcbiAgICBzY2VuZS5hZGQocGFydGljbGVzKTtcclxuXHJcblxyXG4gICAgY29uc3QgcmFkaXVzID0gNTsgLy8gUmVwbGFjZSB3aXRoIHRoZSBkZXNpcmVkIHJhZGl1cyBvZiB0aGUgY2lyY2xlXHJcbiAgICBjb25zdCBzZWdtZW50cyA9IDMyOyAvLyBSZXBsYWNlIHdpdGggdGhlIGRlc2lyZWQgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIGFwcHJveGltYXRlIHRoZSBjaXJjbGVcclxuXHJcbiAgICBjb25zdCBjaXJjbGVUZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCdiYWNrZ3JvdW5kYWxidW0ucG5nJyk7XHJcbiAgICBjb25zdCBjaXJjbGVNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7IG1hcDogY2lyY2xlVGV4dHVyZSB9KTtcclxuICAgIGNvbnN0IGNpcmNsZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkNpcmNsZUdlb21ldHJ5KHJhZGl1cywgc2VnbWVudHMpO1xyXG4gICAgY29uc3QgY2lyY2xlTWVzaCA9IG5ldyBUSFJFRS5NZXNoKGNpcmNsZUdlb21ldHJ5LCBjaXJjbGVNYXRlcmlhbCk7XHJcbiAgICBjaXJjbGVNZXNoLnBvc2l0aW9uLnNldCgwLCAwLCAtMik7XHJcbiAgICBjaXJjbGVNZXNoLnJvdGF0aW9uLnNldCgwLCAwLCAwKTtcclxuICAgIC8vc2NlbmUuYWRkKGNpcmNsZU1lc2gpO1xyXG5cclxuICAgIHRleHR1cmVMb2FkZXIubG9hZCgnY2lyY2xlMjAucG5nJywgKGltYWdlVGV4dHVyZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gNDtcclxuICAgICAgICBjb25zdCBpbWdXaWR0aCA9IGltYWdlVGV4dHVyZS5pbWFnZS53aWR0aCAqIHNjYWxlO1xyXG4gICAgICAgIGNvbnN0IGltZ0hlaWdodCA9IGltYWdlVGV4dHVyZS5pbWFnZS5oZWlnaHQgKiBzY2FsZTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSBpbWdXaWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nSGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBcclxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZVRleHR1cmUuaW1hZ2UsIDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xyXG4gICAgXHJcbiAgICAgICAgY29uc3QgaW1nRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltZ1dpZHRoLCBpbWdIZWlnaHQpLmRhdGE7XHJcbiAgICAgICAgY29uc3QgcmVzb2x1dGlvbkZhY3RvciA9IDE7IC8vIEluY3JlYXNlIHRoaXMgdmFsdWUgZm9yIGEgbW9yZSBwaXhlbGF0ZWQgZWZmZWN0XHJcbiAgICBcclxuICAgICAgICBjb25zdCBwYXJ0aWNsZVRleHR1cmUgPSB0ZXh0dXJlTG9hZGVyLmxvYWQoJ3BhcnRpY2xlc3doaXRlLnBuZycpOyAgICAgICAgY29uc3QgcGFydGljbGVzR2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcclxuICAgICAgICBjb25zdCBwYXJ0aWNsZVZlcnRpY2VzID0gW107XHJcbiAgICAgICAgY29uc3QgcGFydGljbGVDb2xvcnMgPSBbXTtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbFBvc2l0aW9ucyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGluY3JlYXNlZEJyaWdodG5lc3MgPSAwLjQ7IC8vIFBsYWNlIHRoaXMgYmVmb3JlIHRoZSBsb29wXHJcbiAgICBcclxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGltZ0hlaWdodDsgeSArPSByZXNvbHV0aW9uRmFjdG9yKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgaW1nV2lkdGg7IHggKz0gcmVzb2x1dGlvbkZhY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSAoeSAqIGltZ1dpZHRoICsgeCkgKiA0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgciA9IGltZ0RhdGFbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZyA9IGltZ0RhdGFbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBpbWdEYXRhW2luZGV4ICsgMl07XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBicmlnaHRuZXNzID0gMC43MTUyICogciArIDAuMjEyNiAqIGcgKyAwLjA3MjIgKiBiO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJyaWdodG5lc3MgPiAxMjgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4UG9zID0gKCh4IC8gaW1nV2lkdGggLSAwLjUpICogMikgKiBzY2FsZTsgIC8vIG11bHRpcGx5IGJ5IHNjYWxlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeVBvcyA9ICgoeSAvIGltZ0hlaWdodCAtIDAuNSkgKiAtMikgKiBzY2FsZTsgIC8vIG11bHRpcGx5IGJ5IHNjYWxlXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgelBvcyA9IC0xOyAvLyBBZGp1c3QgdGhpcyB2YWx1ZSB0byBzZXQgdGhlIHBhcnRpY2xlcyBmdXJ0aGVyIGJhY2tcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZVZlcnRpY2VzLnB1c2goeFBvcywgeVBvcywgelBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxQb3NpdGlvbnMucHVzaCh4UG9zLCB5UG9zLCB6UG9zKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZUNvbG9ycy5wdXNoKDEsIDEsIDEpOyAvLyBTZXQgUkdCIHZhbHVlcyB0byB3aGl0ZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHBhcnRpY2xlc0dlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShwYXJ0aWNsZVZlcnRpY2VzLCAzKSk7XHJcbiAgICAgICAgcGFydGljbGVzR2VvbWV0cnkuc2V0QXR0cmlidXRlKCdjb2xvcicsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKHBhcnRpY2xlQ29sb3JzLCAzKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcGFydGljbGVzTWF0ZXJpYWwgPSBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoeyBcclxuICAgICAgICAgICAgc2l6ZTogMC4wMiwgLy8gSW5jcmVhc2UgdGhpcyB2YWx1ZSBmb3IgYSBtb3JlIHBpeGVsYXRlZCBlZmZlY3RcclxuICAgICAgICAgICAgbWFwOiBwYXJ0aWNsZVRleHR1cmUsIFxyXG4gICAgICAgICAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsIFxyXG4gICAgICAgICAgICB0cmFuc3BhcmVudDogdHJ1ZSxcclxuICAgICAgICAgICAgb3BhY2l0eTogMC4wMSwgLy8gQWRqdXN0IHRoaXMgdmFsdWVcclxuICAgICAgICAgICAgY29sb3I6IG5ldyBUSFJFRS5Db2xvcigxLCAxLCAxKSAvLyBXaGl0ZVxyXG5cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBwYXJ0aWNsZXMgPSBuZXcgVEhSRUUuUG9pbnRzKHBhcnRpY2xlc0dlb21ldHJ5LCBwYXJ0aWNsZXNNYXRlcmlhbCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgc2NlbmUuYWRkKHBhcnRpY2xlcyk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4vLyAxLiBMb2FkIHRoZSBmaXJlIHRleHR1cmVcclxuY29uc3QgZmlyZVRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZUxvYWRlcigpLmxvYWQoJ2NpcmNsZTQucG5nJyk7XHJcblxyXG4vLyAyLiBDcmVhdGUgdGhlIHBhcnRpY2xlIHN5c3RlbSBtYXRlcmlhbFxyXG5jb25zdCBmaXJlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuUG9pbnRzTWF0ZXJpYWwoe1xyXG4gICAgbWFwOiBmaXJlVGV4dHVyZSxcclxuICAgIGJsZW5kaW5nOiBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nLFxyXG4gICAgc2l6ZTogMC4xLCAgLy8gSW5jcmVhc2UgdGhlIHNpemUgZm9yIG92ZXJsYXBcclxuICAgIHRyYW5zcGFyZW50OiB0cnVlLFxyXG4gICAgb3BhY2l0eTogMC4wNSxcclxuICAgIHZlcnRleENvbG9yczogdHJ1ZSxcclxuICAgIGRlcHRoV3JpdGU6IGZhbHNlICAvLyBUbyBlbnN1cmUgcGFydGljbGVzIGJsZW5kIHByb3Blcmx5IHdpdGhvdXQgZGVwdGggaW50ZXJmZXJlbmNlXHJcbn0pO1xyXG5cclxuLy8gMy4gQ3JlYXRlIHRoZSBwYXJ0aWNsZSBzeXN0ZW0gZ2VvbWV0cnlcclxuY29uc3QgZmlyZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcbmNvbnN0IGZpcmVWZXJ0aWNlcyA9IFtdO1xyXG5jb25zdCBmaXJlQ29sb3JzID0gW107XHJcbmNvbnN0IGZpcmVTaXplcyA9IFtdO1xyXG5cclxuZm9yIChsZXQgaSA9IDA7IGkgPCA1MDAwOyBpKyspIHsgIC8vIEluY3JlYXNlIHRoZSBudW1iZXIgb2YgcGFydGljbGVzIGZvciBkZW5zaXR5XHJcbiAgICBjb25zdCB4ID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMjtcclxuICAgIGNvbnN0IHkgPSBNYXRoLnJhbmRvbSgpIC0gMjtcclxuICAgIGNvbnN0IHogPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyO1xyXG4gICAgZmlyZVZlcnRpY2VzLnB1c2goeCwgeSwgeik7XHJcblxyXG4gICAgY29uc3QgaHVlID0gMTAgKyBNYXRoLnJhbmRvbSgpICogMTA7XHJcbiAgICBjb25zdCBzYXR1cmF0aW9uID0gODAgKyBNYXRoLnJhbmRvbSgpICogMjA7XHJcbiAgICBjb25zdCBsaWdodG5lc3MgPSA0MCArIE1hdGgucmFuZG9tKCkgKiAyO1xyXG4gICAgY29uc3QgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoYGhzbCgke2h1ZX0sICR7c2F0dXJhdGlvbn0lLCAke2xpZ2h0bmVzc30lKWApO1xyXG4gICAgZmlyZUNvbG9ycy5wdXNoKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xyXG59XHJcbmZpcmVHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoZmlyZVZlcnRpY2VzLCAzKSk7XHJcbmZpcmVHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ2NvbG9yJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoZmlyZUNvbG9ycywgMykpO1xyXG5maXJlR2VvbWV0cnkuc2V0QXR0cmlidXRlKCdzaXplJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoZmlyZVNpemVzLCAxKSk7IC8vIE5FVzogU2V0IHZhcnlpbmcgc2l6ZXNcclxuXHJcbmNvbnN0IGZpcmVQYXJ0aWNsZXMgPSBuZXcgVEhSRUUuUG9pbnRzKGZpcmVHZW9tZXRyeSwgZmlyZU1hdGVyaWFsKTtcclxuc2NlbmUuYWRkKGZpcmVQYXJ0aWNsZXMpO1xyXG5cclxuLy8gNC4gQW5pbWF0ZSB0aGUgZmlyZSBwYXJ0aWNsZXMgaW4geW91ciBhbmltYXRlIGZ1bmN0aW9uXHJcbmZ1bmN0aW9uIGFuaW1hdGVGaXJlKCkge1xyXG4gICAgY29uc3QgcG9zaXRpb25zID0gZmlyZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICAgIHBvc2l0aW9uc1tpICsgMV0gKz0gMC4wMDUgKyBNYXRoLnJhbmRvbSgpICogMC4wMTsgLy8gQWRkIHJhbmRvbW5lc3MgdG8gdXB3YXJkIG1vdmVtZW50XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uc1tpICsgMV0gPiAwLjUpIHtcclxuICAgICAgICAgICAgcG9zaXRpb25zW2kgKyAxXSA9IC0wLjU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvc2l0aW9uc1tpXSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAxOyAvLyBBZGQgc2xpZ2h0IHJhbmRvbW5lc3MgdG8geCBwb3NpdGlvbiBmb3IgZmxpY2tlclxyXG4gICAgfVxyXG4gICAgZmlyZUdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG59XHJcbi8vIDEuIExvYWQgdGhlIGZpcmUyIHRleHR1cmVcclxuY29uc3QgZmlyZTJUZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmVMb2FkZXIoKS5sb2FkKCdwYXJ0aWNsZXNyZWQucG5nJyk7IC8vIENoYW5nZSB0aGUgcGF0aCB0byB0aGUgbmV3IHRleHR1cmVcclxuXHJcbi8vIDIuIENyZWF0ZSB0aGUgcGFydGljbGUgc3lzdGVtIG1hdGVyaWFsIGZvciBmaXJlMlxyXG5jb25zdCBmaXJlMk1hdGVyaWFsID0gbmV3IFRIUkVFLlBvaW50c01hdGVyaWFsKHtcclxuICAgIG1hcDogZmlyZTJUZXh0dXJlLFxyXG4gICAgYmxlbmRpbmc6IFRIUkVFLkFkZGl0aXZlQmxlbmRpbmcsXHJcbiAgICBzaXplOiAwLjA4LCAgLy8gU2xpZ2h0bHkgZGlmZmVyZW50IHNpemUgZm9yIHZhcmlhdGlvblxyXG4gICAgdHJhbnNwYXJlbnQ6IHRydWUsXHJcbiAgICBvcGFjaXR5OiAwLjAwNiwgIC8vIFNsaWdodGx5IGxlc3Mgb3BhY2l0eSBmb3IgdmFyaWF0aW9uXHJcbiAgICB2ZXJ0ZXhDb2xvcnM6IHRydWUsXHJcbiAgICBkZXB0aFdyaXRlOiBmYWxzZVxyXG59KTtcclxuXHJcbi8vIDMuIENyZWF0ZSB0aGUgcGFydGljbGUgc3lzdGVtIGdlb21ldHJ5IGZvciBmaXJlMlxyXG5jb25zdCBmaXJlMkdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XHJcbmNvbnN0IGZpcmUyVmVydGljZXMgPSBbXTtcclxuY29uc3QgZmlyZTJDb2xvcnMgPSBbXTtcclxuY29uc3QgZmlyZTJTaXplcyA9IFtdO1xyXG5cclxuZm9yIChsZXQgaSA9IDA7IGkgPCA0MDAwOyBpKyspIHsgIC8vIFNsaWdodGx5IGZld2VyIHBhcnRpY2xlcyBmb3IgdmFyaWF0aW9uXHJcbiAgICBjb25zdCB4ID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMi41OyAgLy8gV2lkZXIgc3ByZWFkXHJcbiAgICBjb25zdCB5ID0gTWF0aC5yYW5kb20oKSAtIDEuNTtcclxuICAgIGNvbnN0IHogPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLjU7ICAvLyBXaWRlciBzcHJlYWRcclxuICAgIGZpcmUyVmVydGljZXMucHVzaCh4LCB5LCB6KTtcclxuXHJcbiAgICBjb25zdCBodWUgPSA1ICsgTWF0aC5yYW5kb20oKSAqIDE1OyAgLy8gRGlmZmVyZW50IGNvbG9yIHZhcmlhdGlvblxyXG4gICAgY29uc3Qgc2F0dXJhdGlvbiA9IDg1ICsgTWF0aC5yYW5kb20oKSAqIDE1O1xyXG4gICAgY29uc3QgbGlnaHRuZXNzID0gMzUgKyBNYXRoLnJhbmRvbSgpICogMztcclxuICAgIGNvbnN0IGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKGBoc2woJHtodWV9LCAke3NhdHVyYXRpb259JSwgJHtsaWdodG5lc3N9JSlgKTtcclxuICAgIGZpcmUyQ29sb3JzLnB1c2goY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XHJcbn1cclxuZmlyZTJHZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoZmlyZTJWZXJ0aWNlcywgMykpO1xyXG5maXJlMkdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZShmaXJlMkNvbG9ycywgMykpO1xyXG5maXJlMkdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnc2l6ZScsIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKGZpcmUyU2l6ZXMsIDEpKTsgXHJcblxyXG5jb25zdCBmaXJlMlBhcnRpY2xlcyA9IG5ldyBUSFJFRS5Qb2ludHMoZmlyZTJHZW9tZXRyeSwgZmlyZTJNYXRlcmlhbCk7XHJcbnNjZW5lLmFkZChmaXJlMlBhcnRpY2xlcyk7XHJcblxyXG4vLyA0LiBBbmltYXRlIHRoZSBmaXJlMiBwYXJ0aWNsZXMgaW4geW91ciBhbmltYXRlIGZ1bmN0aW9uXHJcbmZ1bmN0aW9uIGFuaW1hdGVGaXJlMigpIHtcclxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IGZpcmUyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgICAgcG9zaXRpb25zW2kgKyAxXSArPSAwLjAwNCArIE1hdGgucmFuZG9tKCkgKiAwLjAwOTsgLy8gRGlmZmVyZW50IG1vdmVtZW50IHNwZWVkXHJcbiAgICAgICAgaWYgKHBvc2l0aW9uc1tpICsgMV0gPiAwLjYpIHtcclxuICAgICAgICAgICAgcG9zaXRpb25zW2kgKyAxXSA9IC0wLjY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvc2l0aW9uc1tpXSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjAxMjsgLy8gRGlmZmVyZW50IGZsaWNrZXJcclxuICAgIH1cclxuICAgIGZpcmUyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbn1cclxuLy8gQ3JlYXRlIGEgcmVkIHNxdWFyZSBwbGFuZSBnZW9tZXRyeVxyXG5jb25zdCBzcXVhcmVTaXplID0gNC41OyAvLyBBZGp1c3QgdGhlIHNpemUgYXMgbmVlZGVkXHJcbmNvbnN0IHNxdWFyZUdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoc3F1YXJlU2l6ZSwgc3F1YXJlU2l6ZSk7XHJcbmNvbnN0IHNxdWFyZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmYwMDAwIH0pOyAvLyBSZWQgY29sb3JcclxuXHJcbmNvbnN0IHNxdWFyZU1lc2ggPSBuZXcgVEhSRUUuTWVzaChzcXVhcmVHZW9tZXRyeSwgc3F1YXJlTWF0ZXJpYWwpO1xyXG5zcXVhcmVNZXNoLnJvdGF0aW9uLnggPSAtTWF0aC5QSSAvIDI7IC8vIFJvdGF0ZSB0aGUgc3F1YXJlIDkwIGRlZ3JlZXMgdG8gbGF5IGl0IGZsYXRcclxuc3F1YXJlTWVzaC5wb3NpdGlvbi5zZXQoMCwgLTIuNywgMCk7IC8vIEFkanVzdCB0aGUgeS12YWx1ZSB0byBzZXQgdGhlIGhlaWdodCBvZiB0aGUgZ3JvdW5kXHJcbnNjZW5lLmFkZChzcXVhcmVNZXNoKTtcclxuXHJcbiAgICAvLyBUaGVuLCBpbiB5b3VyIGFuaW1hdGUgZnVuY3Rpb246XHJcbiAgICBmdW5jdGlvbiBhbmltYXRlKCkge1xyXG4gICAgICAgIGFuaW1hdGVGaXJlKCk7XHJcbiAgICAgICAgYW5pbWF0ZUZpcmUyKCk7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gcGFydGljbGVzR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcclxuICAgICAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKSAqIDAuMDAwMTsgIC8vIGFkanVzdCB0aGUgbXVsdGlwbGllciB0byBjb250cm9sIHRoZSBzcGVlZCBvZiB0aGUgYW5pbWF0aW9uXHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgICAgICAgIGxldCBwYXJ0aWNsZVBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXSwgcG9zaXRpb25zW2kgKyAyXSk7XHJcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFBvcyA9IG5ldyBUSFJFRS5WZWN0b3IzKG9yaWdpbmFsUG9zaXRpb25zW2ldLCBvcmlnaW5hbFBvc2l0aW9uc1tpICsgMV0sIG9yaWdpbmFsUG9zaXRpb25zW2kgKyAyXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBhcnRpY2xlIGFuZCB0aGUgbW91c2VcclxuICAgICAgICAgICAgbGV0IGRpc3RhbmNlVG9Nb3VzZSA9IHBhcnRpY2xlUG9zLmRpc3RhbmNlVG8obW91c2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGRpc3RhbmNlIGlzIGxlc3MgdGhhbiB0aGUgbW91c2VSYWRpdXMsIG1vdmUgdGhlIHBhcnRpY2xlIHRvd2FyZHMgdGhlIG1vdXNlXHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZVRvTW91c2UgPCBtb3VzZVJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgcGFydGljbGVQb3MubGVycChtb3VzZSwgbW91c2VTdHJlbmd0aCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIG1vdmUgdGhlIHBhcnRpY2xlIGJhY2sgdG8gaXRzIG9yaWdpbmFsIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZVBvcy5sZXJwKG9yaWdpbmFsUG9zLCAwLjA1KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBub2lzZSBmdW5jdGlvbiB0byBnZXQgYSBzbW9vdGgsIHZhcnlpbmcgdmFsdWUgZm9yIGVhY2ggcGFydGljbGVcclxuICAgICAgICAgICAgY29uc3Qgbm9pc2VWYWx1ZSA9IG5vaXNlM0RGdW5jdGlvbihwYXJ0aWNsZVBvcy54LCBwYXJ0aWNsZVBvcy55LCB0aW1lKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgbm9pc2UgdmFsdWUgdG8gYWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgcGFydGljbGVcclxuICAgICAgICAgICAgcGFydGljbGVQb3MueiArPSBub2lzZVZhbHVlICogMC4wMTsgIC8vIGFkanVzdCB0aGUgbXVsdGlwbGllciB0byBjb250cm9sIHRoZSBhbXBsaXR1ZGUgb2YgdGhlIGFuaW1hdGlvblxyXG5cclxuICAgICAgICAgICAgcG9zaXRpb25zW2ldID0gcGFydGljbGVQb3MueDtcclxuICAgICAgICAgICAgcG9zaXRpb25zW2kgKyAxXSA9IHBhcnRpY2xlUG9zLnk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uc1tpICsgMl0gPSBwYXJ0aWNsZVBvcy56O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFydGljbGVzR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG4gICAgICAgIC8vcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xyXG4gICAgICAgIGNvbXBvc2VyLnJlbmRlcigpO1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBhbmltYXRlKCk7XHJcbn0pO1xyXG5cclxuY2FtZXJhLnBvc2l0aW9uLnogPSAxLjM4O1xyXG5cclxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsICgpID0+IHtcclxuICAgIGNvbnN0IG5ld1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICBjb25zdCBuZXdIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcblxyXG4gICAgY2FtZXJhLmFzcGVjdCA9IG5ld1dpZHRoIC8gbmV3SGVpZ2h0O1xyXG4gICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbiAgICByZW5kZXJlci5zZXRTaXplKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xyXG4gICAgY29tcG9zZXIuc2V0U2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcclxufSk7XHJcbn0iXSwibmFtZXMiOlsiVEhSRUUiLCJFZmZlY3RDb21wb3NlciIsIlJlbmRlclBhc3MiLCJVbnJlYWxCbG9vbVBhc3MiLCJjcmVhdGVOb2lzZTNEIiwiaW5pdGlhbGl6ZVRocmVlSlMiLCJtb3VudFBvaW50Iiwibm9pc2UzREZ1bmN0aW9uIiwic2NlbmUiLCJTY2VuZSIsImZvZyIsIkZvZ0V4cDIiLCJjYW1lcmEiLCJQZXJzcGVjdGl2ZUNhbWVyYSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInJlbmRlcmVyIiwiV2ViR0xSZW5kZXJlciIsImFscGhhIiwic2V0U2l6ZSIsInNldENsZWFyQ29sb3IiLCJkb2N1bWVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImRvbUVsZW1lbnQiLCJjb21wb3NlciIsInJlbmRlclBhc3MiLCJhZGRQYXNzIiwiYmxvb21PcHRpb25zIiwic3RyZW5ndGgiLCJyYWRpdXMiLCJ0aHJlc2hvbGQiLCJibG9vbVBhc3MiLCJWZWN0b3IyIiwidGV4dHVyZUxvYWRlciIsIlRleHR1cmVMb2FkZXIiLCJtb3VzZSIsIm1vdXNlUmFkaXVzIiwibW91c2VTdHJlbmd0aCIsInJheWNhc3RlciIsIlJheWNhc3RlciIsImNhbWVyYVBhcmFsbGF4RmFjdG9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJ4IiwiY2xpZW50WCIsInkiLCJjbGllbnRZIiwieiIsInNldEZyb21DYW1lcmEiLCJyYXkiLCJhdCIsInBvc2l0aW9uIiwibG9va0F0IiwiaGFuZGxlVG91Y2giLCJwcmV2ZW50RGVmYXVsdCIsInRvdWNoZXMiLCJsZW5ndGgiLCJ0b3VjaCIsInNjYWxlIiwibG9hZCIsImltYWdlVGV4dHVyZSIsImltZ1dpZHRoIiwiaW1hZ2UiLCJ3aWR0aCIsImltZ0hlaWdodCIsImhlaWdodCIsImNhbnZhcyIsImNyZWF0ZUVsZW1lbnQiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsImltZ0RhdGEiLCJnZXRJbWFnZURhdGEiLCJkYXRhIiwicmVzb2x1dGlvbkZhY3RvciIsInBhcnRpY2xlVGV4dHVyZSIsInBhcnRpY2xlc0dlb21ldHJ5IiwiQnVmZmVyR2VvbWV0cnkiLCJwYXJ0aWNsZVZlcnRpY2VzIiwicGFydGljbGVDb2xvcnMiLCJvcmlnaW5hbFBvc2l0aW9ucyIsImluY3JlYXNlZEJyaWdodG5lc3MiLCJpbmRleCIsInIiLCJnIiwiYiIsImJyaWdodG5lc3MiLCJ4UG9zIiwieVBvcyIsInB1c2giLCJzZXRBdHRyaWJ1dGUiLCJGbG9hdDMyQnVmZmVyQXR0cmlidXRlIiwicGFydGljbGVzTWF0ZXJpYWwiLCJQb2ludHNNYXRlcmlhbCIsInNpemUiLCJtYXAiLCJ2ZXJ0ZXhDb2xvcnMiLCJ0cmFuc3BhcmVudCIsIm9wYWNpdHkiLCJwYXJ0aWNsZXMiLCJQb2ludHMiLCJhZGQiLCJzZWdtZW50cyIsImNpcmNsZVRleHR1cmUiLCJjaXJjbGVNYXRlcmlhbCIsIk1lc2hCYXNpY01hdGVyaWFsIiwiY2lyY2xlR2VvbWV0cnkiLCJDaXJjbGVHZW9tZXRyeSIsImNpcmNsZU1lc2giLCJNZXNoIiwic2V0Iiwicm90YXRpb24iLCJ6UG9zIiwiY29sb3IiLCJDb2xvciIsImZpcmVUZXh0dXJlIiwiZmlyZU1hdGVyaWFsIiwiYmxlbmRpbmciLCJBZGRpdGl2ZUJsZW5kaW5nIiwiZGVwdGhXcml0ZSIsImZpcmVHZW9tZXRyeSIsImZpcmVWZXJ0aWNlcyIsImZpcmVDb2xvcnMiLCJmaXJlU2l6ZXMiLCJpIiwiTWF0aCIsInJhbmRvbSIsImh1ZSIsInNhdHVyYXRpb24iLCJsaWdodG5lc3MiLCJmaXJlUGFydGljbGVzIiwiYW5pbWF0ZUZpcmUiLCJwb3NpdGlvbnMiLCJhdHRyaWJ1dGVzIiwiYXJyYXkiLCJuZWVkc1VwZGF0ZSIsImZpcmUyVGV4dHVyZSIsImZpcmUyTWF0ZXJpYWwiLCJmaXJlMkdlb21ldHJ5IiwiZmlyZTJWZXJ0aWNlcyIsImZpcmUyQ29sb3JzIiwiZmlyZTJTaXplcyIsImZpcmUyUGFydGljbGVzIiwiYW5pbWF0ZUZpcmUyIiwic3F1YXJlU2l6ZSIsInNxdWFyZUdlb21ldHJ5IiwiUGxhbmVHZW9tZXRyeSIsInNxdWFyZU1hdGVyaWFsIiwic3F1YXJlTWVzaCIsIlBJIiwiYW5pbWF0ZSIsInRpbWUiLCJEYXRlIiwibm93IiwicGFydGljbGVQb3MiLCJWZWN0b3IzIiwib3JpZ2luYWxQb3MiLCJkaXN0YW5jZVRvTW91c2UiLCJkaXN0YW5jZVRvIiwibGVycCIsIm5vaXNlVmFsdWUiLCJyZW5kZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/app2.js\n"));

/***/ })

});